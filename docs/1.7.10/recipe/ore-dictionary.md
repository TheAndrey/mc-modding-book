description: Работа со словарём руд.

# Словарь руд

Словарь руд предназначен в первую очередь для обеспечения лучшей совместимости между модами, решая проблему дублирующихся руд и других предметов.
Чуть ли не каждый технический мод считает своим долгом добавить в игру оловянную и медную руду, в результате в сборке появляется с десяток видов одной и той же руды.
Словарь руд решает эту проблему, делая руды из различных модификаций взаимозаменяемыми.

Предметы, зарегистрированные в `OreDictionary`, становятся эквивалентны другим предметам, входящим в ту же группу словаря, что и зарегистрированный. 
Это позволяет использовать [в рецептах словаря](basics.md) любой предмет из группы, указав её имя, для получения одного и того же результата.

Несмотря на свое название, `OreDictionary` используется не только для руд. Любой предмет, похожий на другой предмет (например, красители), 
может быть зарегистрирован в `OreDictionary`.

## Именование групп

!!! note "Примечание"
    Старайтесь использовать имена существующих [групп словаря](oredict-table.md), прежде чем придумывать свою, 
    иначе смысл от использования словаря стремится к нулю.

Forge явно не требует, чтобы имена были в каком-либо определенном формате, но следующее стало популярным стандартом для имен OreDictionary:

1. Имя группы должно использовать [camelCase](https://ru.wikipedia.org/wiki/CamelCase) и должно начинаться со строчной буквы (пример: `oreHello`).
2. Первое слово указывает на тип элемента.
     * `ore` – руды (блок)
     * `wood` – древесина (блок)
     * `gem` – драгоценные камни (предмет)
     * `ingot` – слитки (предмет)
     * `block` – Различные блоки
     * `dust` – Пыль (предмет)
     * `wires` – Провода
     * `nuggets` – Самородки (предмет)
     * `crops` – Семена и растения без семян (предмет)
     * `material` – Предметы из определённого вида материала
3. Второе указывает материал предмета. Для уникальных предметов (таких, как `record`, `dirt`, `egg` и `vine`) материал не требуется.
4. Третьим указывается цвет блока/предмета, если предметы имеют разновидности по цвету (пример: `blockGlassLightGray`). 

Когда два слова недостаточно конкретны, можно добавить третье слово. Например, кирпич зарегистрировано как `ingotBrick`, в то время как адский кирпич зарегистрировано как `ingotBrickNether`.

## Регистрация предметов в словаре руд

Доступно три метода для регистрации предмета в словаре руд.
Первым параметром идёт имя группы, вторым - предмет, который мы хотим добавить в группу.
При отсутствии группы с указанным именем, она будет создана автоматически.

1. `OreDictionary#registerOre(String, Item)` - регистрация предмета, когда **damage** неважен.
2. `OreDictionary#registerOre(String, Block)` - регистрация блока, когда **meta** неважна.
3. `OreDictionary#registerOre(String, ItemStack)` - регистрирует предмет/блок с конкретным значением **damage**.

!!! tip "Совет"
    Для `ItemStack` можно задать магическое значение **damage** `WILDCARD_VALUE`, для указания на то, что **damage** предмета не важен.
    Методы регистрации `Item` и `Block` используют данный подход.

Зарегистрируем рубин, рубиновый блок и воздушные шарики в словаре руд.

```java
package ru.mcmodding.tutorial.common.handler;

import net.minecraft.item.ItemStack;
import net.minecraftforge.oredict.OreDictionary;

public class ModRecipes {
    public static void registerRecipes() {
        // ...
    }

    public static void registerOres() {
        OreDictionary.registerOre("blockRuby", ModBlocks.RUBY);
        OreDictionary.registerOre("gemRuby", ModItems.RUBY);
        OreDictionary.registerOre("balloon", new ItemStack(ModItems.BALLOON, 1, OreDictionary.WILDCARD_VALUE));
    }
}
```

Затем необходимо вызвать метод `ModRecipes#registerOres` в `CommonProxy#postInit`, до регистрации основных рецептов.

```java hl_lines="9"
package ru.mcmodding.tutorial.common;

import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import ru.mcmodding.tutorial.common.handler.*;

public class CommonProxy implements IGuiHandler {

    public void postInit(FMLPostInitializationEvent event) {
        ModRecipes.registerOres();
        ModRecipes.registerRecipes();
    }
}
```

## API OreDictionary

В классе `OreDictionary` существуют вспомогательные методы:

* `getOreID(String)` - возвращает ID указанной группы. 
   Если группы не существует, будет создана новая и возвращён её ID.
* `getOreName(int)` - возвращает имя группы по ID.
* `getOreID(ItemStack)` - Возвращает первое имя группы в которую входит предмет.
   **Данный метод объявлен устаревшим** так как возвращает всего одно имя группы, в то время как предмет может входить сразу в несколько групп. 
   Используйте следующий метод.
* `getOreIDs(ItemStack)` - Возвращает список имён групп словаря в которые входит предмет. Если предмет нигде не числится, вернёт пустой список.
* `getOres(Integer)` - Возвращает список предметов, входящих в указанную группу (по ID). При отсутствии будет создана новая группа.
* `getOres(String)` - Эквивалент предыдущего метода, принимающий имя группы вместо её ID.
* `getOres(String, boolean)` - Эквивалент двух предыдущих методов, с возможностью отключить автоматическое создание группы при её отсутствии.
   Опция должна использоваться разработчиками модификаций, которые выполняют полное сканирование в `postInit`.
   Это значительно уменьшает беспорядок в словаре руд и является правильным способом использования словаря в большинстве случаев.
* `doesOreNameExist(String)` - Проверяет существование группы с указанным именем.
   Может быть использован для безопасного запроса словаря руд без добавления ненужного беспорядка в базовую структуру карты.
   Пожалуйста, используйте этот метод, когда это возможно и уместно.
* `getOreNames()` - Возвращает массив всех имён групп, зарегистрированных в словаре.
* `itemMatches(ItemStack, ItemStack, boolean)` - Проверяет совпадение входящего предмета с целевым по **item** и **damage**.
   Имеет параметр **strict**, который отвечает за строгую проверку `itemDamage` предмета без использования `WILDCARD_VALUE`.
